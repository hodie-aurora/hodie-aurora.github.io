---
layout:     post   				# 使用的布局（不需要改）
title:      01-00-kubernetes基础 			# 标题 
subtitle:   01-00-kubernetes基础 			#副标题
date:       2025-01-14 				# 时间
author:     zhaohaiwen 				# 作者
header-img: img/post-bg-2025-01-07.jpg		#这篇文章标题背景图片
catalog: true 					# 是否归档
tags:						#标签
    - kubernetes
---
### Kubernetes

#### 1. Kubernetes概念及特性

占位

#### 2. 应用部署

##### **容器荚（Pod）**

pod，什么是pod呢，首先我们要清楚镜像和容器这个概念，镜像其实就是将我们的程序和运行环境（例如包含JRE的Ubuntu操作系统）一起打包成一个只读的、分为很多层的一个文件，这里读者可以简单认为它被打包成了一个文件，而把这个文件“激活”，运行起来，就变成了一个容器，这个容器启动的过程也有很多内容要讲，不过先别急我们今天只讨论基础的内容，说回容器，这个容器如同一台及其微小的linux机器一样，有独立的网络、存储、磁盘和内存，也就是说容器是把你的程序运行在一台非常微小的linux系统上，只不过是单例模式运行的，假如你的容器里的应用是应用A，此时如果我们有一些其他程序和这个容器（应用A）关系很密切，例如给这个容器（应用A）提供日志记录啦、或者你的应用（应用A）要密切依赖另外一个应用啦（应用B）、或是你的容器（应用A）无法独立运行啦，你就需要部署另外一个容器B和之前的容器A进行配合，但是容器与容器之间很多资源是不共享的，比如跨容器访问会带来效率问题，而且假如容器B挂掉了，容器A的部分功能可能就无法使用了，那能不能让这个两个容器之间的关系变得更密切呢，此时容器荚（pod）出现了，顾名思义，容器荚就像一个豆荚一样，里面的豆子就是容器，就我们刚才的案例来说，假如你的容器B挂掉了，那么容器荚（pod）的上级rs就会重新启动这个容器荚，从而重新部署这两个容器，达到高可用的目的，而且pod内的容器共享同一网络命名空间，可以直接通过 `localhost` 通信，大大提升了沟通效率，如果不在一个pod内容器之间的通信可能会跨网段，当然这是后话了，我们之后会讲，目前您只要记住，容器荚（pod）就像一个豆荚，包裹着容器，与容器共存亡。

##### **复制控制器（Replication Controller）和复制集（ReplicaSet）**

Replication Controller，通常被成为"RC"，ReplicaSet通常被成为”RS“，RC可以控制一组pod（几个相同的pod），维持pod的指定数量，如果说某个pod发生异常：比如pod崩溃或是pod被删除，RC就可以创建出一个新的pod来代替已死亡的pod。假如我想调整这组pod的数量，我们就可以通过调整RC的yaml来控制这组pod的数量，当然，RC只是一个基础组件，我们通常不会用到它，正常情况下都是通过deployment、statefulset、daemonset这些更高级的组件去控制RC，说回RC，假如我们的应用更新了一个版本，此时要更新这组pod的镜像，我们只需要修改RC中yaml的镜像配置即可，RC会逐个杀死pod并且创建出使用新镜像的pod，RS的功能与RC类似，不过RS更为灵活，可以进行灵活的版本回滚等操作，所以目前高级组件控制的都是RS,至于RC和RS的工作原理，我们后续会讲。

##### **部署集（Deployment）**

Deployment，通常被翻译成部署，也会被翻译为部署集，但我更愿意称之为“无状态发布”（虽然这不是标准术语，但Deployment部署的服务通常是无状态的）。Deployment会控制RS（ReplicaSet）来实现对Pod的管理，并且Deployment的功能更为强大。Deployment 提供了高级的滚动更新参数，如 `maxUnavailable`和 `maxSurge`。`maxUnavailable`定义在更新过程中允许的最大不可用Pod数，而 `maxSurge`定义在更新过程中可以额外创建的Pod数。这些参数使得更新过程更可控，减少了服务中断的风险。而且Deployment 会保留每次更新的历史版本（Revisions），包括更新前后的Pod模板。用户可以指定回滚到具体的历史版本，而不仅仅是回滚到上一个版本。通过管理多个RS，Deployment 可以实现蓝绿部署策略，在新版本完全就绪前，旧版本仍然保持服务，从而确保更新零宕机。简而言之，Deployment通常用来部署无状态应用，并且提供了更加丰富的版本管理、水平拓展和滚动更新等功能。

##### **有状态集（StatefulSet）**

StatefulSet，通常被翻译成有状态集，但我更愿称之为”有状态发布“（非标准术语，因为StatefulSet部署的服务通常是有状态的，比如redis、mysql，与无状态发布相互对应），具体的比较情况请查看文章《kubernetes资源控制器》

##### **守护进程集（DaemonSet）**

DaemonSet，通常被翻译成守护进程集，DaemonSet 通常用于在 Kubernetes 集群中的每个节点上运行特定的 Pod，适用于日志收集、监控和指标收集、集群存储、网络插件管理和系统管理任务。它确保每个节点上都运行一份相同的 Pod 实例，提供一致性和高可用性，简化运维工作。

#### 3. 资源管理

##### **命名空间（Namespace）**

命名空间，通常翻译为命名空间，通常用于将某一类应用放置在同一个命名空间中。假设你现在在你的 Kubernetes 集群中部署了两套业务系统，业务系统 A 和业务系统 B，那么可以将业务系统 A 放在 A 命名空间中，将业务系统 B 放在 B 命名空间中。可以为每个命名空间绑定不同的用户或角色，或者为命名空间单独创建网关，从而尽可能将命名空间内的资源相互隔离，实现互相隔离、互不干扰的效果。

总的来说，Namespace实现了以下功能：

**资源分配和限制：** 命名空间也可以用于设置资源配额（如CPU、内存等），以限制不同团队或项目的资源使用，避免资源争夺。

**安全性：** 命名空间可以结合角色权限控制（RBAC）实现更细粒度的权限管理，确保不同命名空间的用户只能访问特定的资源。

**网络策略：** 可以通过网络策略（Network Policy）来控制命名空间内和命名空间之间的网络流量，从而提高安全性。

##### **标签（Label）**

标签是一种键值对，主要作用是给你的各种资源进行标记，比如你可以给你的某个节点打上Prometheus=true的标签，并且只允许Prometheus部署到含有Prometheus=true标签的节点上，避免Prometheus漂移（确保Prometheus实例始终运行在相同的节点上，避免因节点故障或资源调度导致的迁移）。需要注意的是，标签对键值的字符约束比较严格，键值字符长度不能超过63个字符（当然通常也用不到这么长字符的标签），以及只能包含字母、数字、短横线和下划线。

##### **注解（Annotation）**

注解也是一种键值对，起到注释的功能，类似于标签，但是约束要比标签宽泛的多，你甚至可以把汉字作为键值对的值。当然，注解只起到类似于注释的作用，不会影响资源的操作和调度。

##### **选择器（Selector）**

选择器，可以让你的资源调度到固定的某个节点上，比如让你的某个部署集或状态集调度到节点A上。通常你的集群内的节点性能是不完全相同的，比如某个节点（我们这里称为节点A）拥有比其他节点多的多的内存资源，我们就可以使用selector把redis状态集调度到这个节点A上。当然，使用给节点打上标签，再给状态集打上标签也能起到相同的效果。但是它们的区别是选择器方法比较简单直接，但灵活性较低，使用标签会更为灵活，但是需要手动管理标签。

#### 4. 集群管理

##### **主节点（Master）**

master节点是集群的主节点，一个集群通常有一个或多个master节点，这取决于你的集群配置。kubernetes的组件通常会部署在主节点上，并且主节点在常规情况下不会部署应用。因为kubernetes集群的调度是某种“中心化结构”，调度信息都要经过主节点，集群规模越大，主节点的数量越多，机器配置要求越高。如果主节点全部宕机会导致新的应用无法成功调度，但不会影响目前已经成功部署的应用和服务。

##### **从节点（Node）**

node通常被成为工作节点，也会被成为从节点，主要负责应用和服务的部署，从节点会定期向主节点发送信息，向主节点证明自己”存活“，如果从节点A宕机，那么它在一定时间内没有向主节点发送存活信息，那么主节点会把从节点A设置为NotReady状态，并且把从节点A上的应用迁移到其他从节点，直到从节点A再次向主节点发送存活信息为止。

#### 5. 网络管理

##### **服务（Service）**


##### **入口控制器（Ingress Controller）**


#### 6. 应用配置

##### **配置管理（ConfigMap）**

##### **密钥管理（Secret）**

#### 7. 存储

##### **存储卷（Volume）**

##### **持久化存储卷（PersistentVolume, PV）**

##### **持久化存储卷声明（PersistentVolumeClaim, PVC）**

#### 8. 批量

##### **任务（Job）**

##### **定时任务（CronJob）**

#### 9. 应用权限

##### **角色权限控制（RBAC）**

##### **服务账号（Service Accounts）**

##### **安全上下文（Security Context）**
