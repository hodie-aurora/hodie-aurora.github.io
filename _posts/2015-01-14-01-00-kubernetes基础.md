---
layout:     post   				# 使用的布局（不需要改）
title:      01-00-kubernetes基础 			# 标题 
subtitle:   01-00-kubernetes基础 			#副标题
date:       2025-01-14 				# 时间
author:     zhaohaiwen 				# 作者
header-img: img/post-bg-2025-01-07.jpg		#这篇文章标题背景图片
catalog: true 					# 是否归档
tags:						#标签
    - kubernetes
---
### Kubernetes

#### 1. Kubernetes概念及特性

占位

#### 2. 应用部署

**容器荚（Pod）**

pod，什么是pod呢，首先我们要清楚镜像和容器这个概念，镜像其实就是将我们的程序和运行环境（例如包含JRE的Ubuntu操作系统）一起打包成一个只读的、分为很多层的一个文件，这里读者可以简单认为它被打包成了一个文件，而把这个文件“激活”，运行起来，就变成了一个容器，这个容器启动的过程也有很多内容要讲，不过先别急我们今天只讨论基础的内容，说回容器，这个容器如同一台及其微小的linux机器一样，有独立的网络、存储、磁盘和内存，也就是说容器是把你的程序运行在一台非常微小的linux系统上，只不过是单例模式运行的，假如你的容器里的应用是应用A，此时如果我们有一些其他程序和这个容器（应用A）关系很密切，例如给这个容器（应用A）提供日志记录啦、或者你的应用（应用A）要密切依赖另外一个应用啦（应用B）、或是你的容器（应用A）无法独立运行啦，你就需要部署另外一个容器B和之前的容器A进行配合，但是容器与容器之间很多资源是不共享的，比如跨容器访问会带来效率问题，而且假如容器B挂掉了，容器A的部分功能可能就无法使用了，那能不能让这个两个容器之间的关系变得更密切呢，此时容器荚（pod）出现了，顾名思义，容器荚就像一个豆荚一样，里面的豆子就是容器，就我们刚才的案例来说，假如你的容器B挂掉了，那么容器荚（pod）的上级rs就会重新启动这个容器荚，从而重新部署这两个容器，达到高可用的目的，而且pod内的容器共享同一网络命名空间，可以直接通过 `localhost` 通信，大大提升了沟通效率，如果不在一个pod内容器之间的通信可能会跨网段，当然这是后话了，我们之后会讲，目前您只要记住，容器荚（pod）就像一个豆荚，包裹着容器，与容器共存亡。

**复制控制器（Replication Controller）和复制集（ReplicaSet）**

Replication Controller，通常被成为"RC"，ReplicaSet通常被成为”RS“，RC可以控制一组pod（几个相同的pod），维持pod的指定数量，如果说某个pod发生异常：比如pod崩溃或是pod被删除，RC就可以创建出一个新的pod来代替已死亡的pod。假如我想调整这组pod的数量，我们就可以通过调整RC的yaml来控制这组pod的数量，当然，RC只是一个基础组件，我们通常不会用到它，正常情况下都是通过deployment、statefulset、daemonset这些更高级的组件去控制RC，说回RC，假如我们的应用更新了一个版本，此时要更新这组pod的镜像，我们只需要修改RC中yaml的镜像配置即可，RC会逐个杀死pod并且创建出使用新镜像的pod，RS的功能与RC类似，不过RS更为灵活，可以进行灵活的版本回滚等操作，所以目前高级组件控制的都是RS,至于RC和RS的工作原理，我们后续会讲。

**部署集（Deployment）**

Deployment，通常被翻译成部署，也会被翻译为部署集，但我更愿意称之为“无状态发布”（虽然这不是标准术语，但Deployment部署的服务通常是无状态的）。Deployment会控制RS（ReplicaSet）来实现对Pod的管理，并且Deployment的功能更为强大。Deployment 提供了高级的滚动更新参数，如 `maxUnavailable`和 `maxSurge`。`maxUnavailable`定义在更新过程中允许的最大不可用Pod数，而 `maxSurge`定义在更新过程中可以额外创建的Pod数。这些参数使得更新过程更可控，减少了服务中断的风险。而且Deployment 会保留每次更新的历史版本（Revisions），包括更新前后的Pod模板。用户可以指定回滚到具体的历史版本，而不仅仅是回滚到上一个版本。通过管理多个RS，Deployment 可以实现蓝绿部署策略，在新版本完全就绪前，旧版本仍然保持服务，从而确保更新零宕机。简而言之，Deployment通常用来部署无状态应用，并且提供了更加丰富的版本管理、水平拓展和滚动更新等功能。

**有状态集（StatefulSet）**

StatefulSet，通常被翻译成有状态集，但我更愿称之为”有状态发布“（非标准术语，因为StatefulSet部署的服务通常是有状态的，比如redis、mysql，与无状态发布相互对应），具体的比较情况请查看文章《kubernetes资源控制器》

**守护进程集（DaemonSet）**

DaemonSet，通常被翻译成守护进程集，DaemonSet 通常用于在 Kubernetes 集群中的每个节点上运行特定的 Pod，适用于日志收集、监控和指标收集、集群存储、网络插件管理和系统管理任务。它确保每个节点上都运行一份相同的 Pod 实例，提供一致性和高可用性，简化运维工作。

#### 3. 应用划分

**命名空间（Namespace）**


**标签（Label）**


**注解（Annotation）**


**选择器（Selector）**


#### 4. 集群划分

**Master**


**Node**


#### 5. 网络管理

**服务（Service）**


**入口控制器（Ingress Controller）**


#### 6. 应用配置

**配置管理（ConfigMap）**


**密钥管理（Secret）**


#### 7. 存储

**存储卷（Volume）**


**持久化存储卷（PersistentVolume, PV）**


**持久化存储卷声明（PersistentVolumeClaim, PVC）**


#### 8. 批量

**任务（Job）**


**定时任务（CronJob）**


#### 9. 应用权限

**角色权限控制（RBAC）**


**服务账号（Service Accounts）**


**安全上下文（Security Context）**


#### 10. 应用资源

**资源限额（Resource Quotas）**


**污点和容忍**


**横向Pod扩展器（Horizontal Pod Autoscaler, HPA）**
