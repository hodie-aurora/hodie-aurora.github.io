---
layout:     post   				# 使用的布局（不需要改）
title:      01 kubernetes基础 			# 标题 
subtitle:   Kubernetes 基础系列 			#副标题
date:       2025-01-14 				# 时间
author:     zhaohaiwen 				# 作者
header-img: img/post-bg-2025-01-07.jpg		#这篇文章标题背景图片
catalog: true 					# 是否归档
tags:						#标签
    - Kubernetes 基础系列
---
### Kubernetes基础内容介绍

#### 前言：

本篇文章将通过举例的方式，让读者尽可能简单地理解 Kubernetes 的基础概念，希望能帮助初学者尽快建立对 Kubernetes 各种概念的理解。文章摒弃了通常博客中直接粘贴大段代码、让新手望而却步的做法，改用更加清晰易懂的举例方式说明 Kubernetes 中每种组件的作用。我们将在后续篇章中更加详细地描述这些组件的用法以及实现原理，希望能和大家一起学习，共同进步。

#### 1. Kubernetes概念及特性

Kubernetes是一款基于容器技术的现代分布式系统平台，是Google开源的容器集群管理系统，在Docker技术的基础上，为容器化应用提供了部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。Kubernetes具备完备的集群管理能力，多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、内建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。kubernetes主要有以下功能：

**容器编排**：Kubernetes能够自动化管理大规模的容器集群。它通过编排工具来管理容器的生命周期，包括调度、部署和滚动升级。

**自动化部署和回滚**：Kubernetes支持声明式的配置，可以实现应用程序的自动化部署和回滚。通过配置文件，您可以定义应用的期望状态，Kubernetes将负责将实际状态与期望状态对齐。

**弹性伸缩**：Kubernetes具有强大的弹性伸缩功能。它可以基于资源使用情况自动增加或减少容器数量，确保应用程序在负载高峰期可以应对流量，同时在低负载时节省资源。

**服务发现与负载均衡**：Kubernetes内置了服务发现和负载均衡功能。它可以为每个服务分配一个DNS名称，并自动进行负载均衡，确保流量均匀分布到所有健康的容器实例上。

**自愈能力**：Kubernetes具备自愈能力，它会自动监控容器的状态，并在检测到容器故障时重新调度和重启容器，确保服务的高可用性。

**存储编排**：Kubernetes支持多种类型的持久化存储。它能够将持久化存储卷挂载到容器中，并对存储资源进行动态管理。

**密钥和配置管理**：Kubernetes提供了安全管理应用程序密钥和配置的机制。通过Secrets和ConfigMaps，应用程序可以安全地访问敏感数据和配置文件。

**命名空间和多租户**：Kubernetes支持命名空间，可以用于逻辑分组和隔离资源，支持多租户环境。不同的团队或项目可以在同一个集群中共存，但相互隔离。

**可扩展性和插件机制**：Kubernetes拥有强大的可扩展性，支持自定义资源定义（CRD）和控制器。它的插件机制使得用户可以根据需求扩展Kubernetes的功能。

**监控和日志管理**：Kubernetes集成了多种监控和日志管理工具，可以实时监控应用程序的性能和运行状态，提供详细的日志信息以便诊断和调试。

**多平台支持**：Kubernetes支持多种操作系统和平台，可以运行在本地数据中心、云环境和混合云环境中，提供一致的应用部署和管理体验。

#### 2. 应用部署

##### **容器荚（Pod）**

pod，什么是pod呢，首先我们要清楚镜像和容器这个概念，镜像其实就是将我们的程序和运行环境（例如包含JRE的Ubuntu操作系统）一起打包成一个只读的、分为很多层的一个文件，这里读者可以简单认为它被打包成了一个文件，而把这个文件“激活”，运行起来，就变成了一个容器，这个容器启动的过程也有很多内容要讲，不过先别急我们今天只讨论基础的内容，说回容器，这个容器如同一台及其微小的linux机器一样，有独立的网络、存储、磁盘和内存，也就是说容器是把你的程序运行在一台非常微小的linux系统上，只不过是单例模式运行的，假如你的容器里的应用是应用A，此时如果我们有一些其他程序和这个容器（应用A）关系很密切，例如给这个容器（应用A）提供日志记录啦、或者你的应用（应用A）要密切依赖另外一个应用啦（应用B）、或是你的容器（应用A）无法独立运行啦，你就需要部署另外一个容器B和之前的容器A进行配合，但是容器与容器之间很多资源是不共享的，比如跨容器访问会带来效率问题，而且假如容器B挂掉了，容器A的部分功能可能就无法使用了，那能不能让这个两个容器之间的关系变得更密切呢，此时容器荚（pod）出现了，顾名思义，容器荚就像一个豆荚一样，里面的豆子就是容器，就我们刚才的案例来说，假如你的容器B挂掉了，那么容器荚（pod）的上级rs就会重新启动这个容器荚，从而重新部署这两个容器，达到高可用的目的，而且pod内的容器共享同一网络命名空间，可以直接通过 `localhost` 通信，大大提升了沟通效率，如果不在一个pod内容器之间的通信可能会跨网段，当然这是后话了，我们之后会讲，目前您只要记住，容器荚（pod）就像一个豆荚，包裹着容器，与容器共存亡。

##### **复制控制器（Replication Controller）和复制集（ReplicaSet）**

Replication Controller，通常被成为"RC"，ReplicaSet通常被成为”RS“，RC可以控制一组pod（几个相同的pod），维持pod的指定数量，如果说某个pod发生异常：比如pod崩溃或是pod被删除，RC就可以创建出一个新的pod来代替已死亡的pod。假如我想调整这组pod的数量，我们就可以通过调整RC的yaml来控制这组pod的数量，当然，RC只是一个基础组件，我们通常不会用到它，正常情况下都是通过deployment、statefulset、daemonset这些更高级的组件去控制RC，说回RC，假如我们的应用更新了一个版本，此时要更新这组pod的镜像，我们只需要修改RC中yaml的镜像配置即可，RC会逐个杀死pod并且创建出使用新镜像的pod，RS的功能与RC类似，不过RS更为灵活，可以进行灵活的版本回滚等操作，所以目前高级组件控制的都是RS,至于RC和RS的工作原理，我们后续会讲。

##### **部署集（Deployment）**

Deployment，通常被翻译成部署，也会被翻译为部署集，但我更愿意称之为“无状态发布”（虽然这不是标准术语，但Deployment部署的服务通常是无状态的）。Deployment会控制RS（ReplicaSet）来实现对Pod的管理，并且Deployment的功能更为强大。Deployment 提供了高级的滚动更新参数，如 `maxUnavailable`和 `maxSurge`。`maxUnavailable`定义在更新过程中允许的最大不可用Pod数，而 `maxSurge`定义在更新过程中可以额外创建的Pod数。这些参数使得更新过程更可控，减少了服务中断的风险。而且Deployment 会保留每次更新的历史版本（Revisions），包括更新前后的Pod模板。用户可以指定回滚到具体的历史版本，而不仅仅是回滚到上一个版本。通过管理多个RS，Deployment 可以实现蓝绿部署策略，在新版本完全就绪前，旧版本仍然保持服务，从而确保更新零宕机。简而言之，Deployment通常用来部署无状态应用，并且提供了更加丰富的版本管理、水平拓展和滚动更新等功能。

##### **有状态集（StatefulSet）**

StatefulSet，通常被翻译成有状态集，但我更愿称之为”有状态发布“（非标准术语，因为StatefulSet部署的服务通常是有状态的，比如redis、mysql，与无状态发布相互对应），具体的比较情况请查看文章《kubernetes资源控制器》

##### **守护进程集（DaemonSet）**

DaemonSet，通常被翻译成守护进程集，DaemonSet 通常用于在 Kubernetes 集群中的每个节点上运行特定的 Pod，适用于日志收集、监控和指标收集、集群存储、网络插件管理和系统管理任务。它确保每个节点上都运行一份相同的 Pod 实例，提供一致性和高可用性，简化运维工作。

#### 3. 资源管理

##### **命名空间（Namespace）**

命名空间，通常翻译为命名空间，通常用于将某一类应用放置在同一个命名空间中。假设你现在在你的 Kubernetes 集群中部署了两套业务系统，业务系统 A 和业务系统 B，那么可以将业务系统 A 放在 A 命名空间中，将业务系统 B 放在 B 命名空间中。可以为每个命名空间绑定不同的用户或角色，或者为命名空间单独创建网关，从而尽可能将命名空间内的资源相互隔离，实现互相隔离、互不干扰的效果。

总的来说，Namespace实现了以下功能：

**资源分配和限制：** 命名空间也可以用于设置资源配额（如CPU、内存等），以限制不同团队或项目的资源使用，避免资源争夺。

**安全性：** 命名空间可以结合角色权限控制（RBAC）实现更细粒度的权限管理，确保不同命名空间的用户只能访问特定的资源。

**网络策略：** 可以通过网络策略（Network Policy）来控制命名空间内和命名空间之间的网络流量，从而提高安全性。

##### **标签（Label）**

标签是一种键值对，主要作用是给你的各种资源进行标记，比如你可以给你的某个节点打上Prometheus=true的标签，并且只允许Prometheus部署到含有Prometheus=true标签的节点上，避免Prometheus漂移（确保Prometheus实例始终运行在相同的节点上，避免因节点故障或资源调度导致的迁移）。需要注意的是，标签对键值的字符约束比较严格，键值字符长度不能超过63个字符（当然通常也用不到这么长字符的标签），以及只能包含字母、数字、短横线和下划线。

##### **注解（Annotation）**

注解也是一种键值对，起到注释的功能，类似于标签，但是约束要比标签宽泛的多，你甚至可以把汉字作为键值对的值。当然，注解只起到类似于注释的作用，不会影响资源的操作和调度。

##### **选择器（Selector）**

选择器，可以让你的资源调度到固定的某个节点上，比如让你的某个部署集或状态集调度到节点A上。通常你的集群内的节点性能是不完全相同的，比如某个节点（我们这里称为节点A）拥有比其他节点多的多的内存资源，我们就可以使用selector把redis状态集调度到这个节点A上。当然，使用给节点打上标签，再给状态集打上标签也能起到相同的效果。但是它们的区别是选择器方法比较简单直接，但灵活性较低，使用标签会更为灵活，但是需要手动管理标签。

#### 4. 集群管理

##### **主节点（Master）**

master节点是集群的主节点，一个集群通常有一个或多个master节点，这取决于你的集群配置。kubernetes的组件通常会部署在主节点上，并且主节点在常规情况下不会部署应用。因为kubernetes集群的调度是某种“中心化结构”，调度信息都要经过主节点，集群规模越大，主节点的数量越多，机器配置要求越高。如果主节点全部宕机会导致新的应用无法成功调度，但不会影响目前已经成功部署的应用和服务。

##### **从节点（Node）**

node通常被成为工作节点，也会被成为从节点，主要负责应用和服务的部署，从节点会定期向主节点发送信息，向主节点证明自己”存活“，如果从节点A宕机，那么它在一定时间内没有向主节点发送存活信息，那么主节点会把从节点A设置为NotReady状态，并且把从节点A上的应用迁移到其他从节点，直到从节点A再次向主节点发送存活信息为止。

#### 5. 网络管理

##### **服务（Service）**

根据前面的内容，相比读者已经了解我们是如何在集群上部署应用的了，但是我们要如何访问到我们的应用呢？这就需要使用到Service

Service 有三种类型：ClusterIP、NodePort 和 LoadBalancer。ClusterIP 主要用于集群内部访问。假设我们部署了一个 Deployment A，这个部署中有一个 Pod A，Pod A 运行着我们开发的服务。要访问该服务需要通过容器的端口，比如设置容器端口为 8080，此时可以通过 Pod A 的 IP 加上容器端口来访问应用。然而，Pod 的 IP 总是变化，不可能每次都去查看 Pod 的 IP，因此需要一个不那么经常变动的 IP。这时可以创建一个 ClusterIP 类型的 Service，这个 Service 的 IP 比 Pod 的 IP 稳定。使用 Service 将 Pod A 的 8080 端口映射为 80（当然可以映射成其他端口），然后使用 Service 的 IP 加上 Service 的端口来访问 Pod A 中的服务。这仅限于集群内部访问，因为集群外部无法知道这个 Service 的 IP。此时您会想到，如果我想在集群外访问这个服务应该怎么办呢，此时就轮到NodePort登场了。

NodePort，也是Service的一个类型，用来解决在集群外部访问应用的问题，NodePort可以将你的service端口再次映射为一个新的端口（通常在30000到32767之间），此时您就可以使用您集群的任意一个节点的ip加上这个NodePort端口来访问您的服务。

LoadBalancer 也是 Service 的一种类型，用于将集群内的服务暴露给外部网络。它会向云提供商（如 AWS、GCP 或 Azure）请求创建一个外部负载均衡器，并分配一个公共 IP 地址。这使得外部用户能够通过这个固定的 IP 地址访问集群内的服务，并将流量分配到多个节点上，确保高可用性和负载均衡。LoadBalancer 通常在云平台上使用，因为它依赖于云提供商的外部负载均衡器。在自建集群中，通常不会使用 LoadBalancer，而是使用 NodePort 或者配置反向代理（如 Nginx 或 Traefik）来实现负载均衡和对外部网络的访问。这些方法虽然没有云平台的 LoadBalancer 那么方便，但仍然可以有效地暴露服务。

##### **入口控制器（Ingress Controller）**

Ingress是kubernetes提供的基础流量控制组件，提供了一些基础的功能，比如Ingress可以用来将节点的ip进行域名映射，或是提供负载均衡：假如我有两个服务，服务A和服务B，ingress也可以起到负载均衡的作用，可以把某个端口比如30200映射为这两个服务的统一入口，从而实现灰度发布或是金丝雀发布。ingress也可以实现根据不同路由分发到不同的服务，比如将 example.com/app1 路由到 app1 服务，将 example.com/app2 路由到 app2 服务，ingress也可以确保访问必须使用tls证书，也可以设置基于IP的白名单和黑名单。Ingress提供的功能很有效，但是比较基础，可以通过在集群中部署traefik来使用ingressRoute或是安装gateway来使用HTTPRoute来实现更加复杂的功能，我们在后续的文章里会进行讲解。

#### 6. 应用配置

##### **配置管理（ConfigMap）**

很好，现在我们经过之前的介绍，我们已经可以部署应用并且通过service访问它们了。但是还有一个小问题，就是我们应用的配置文件是从容器里的配置文件中进行读取的，这看似没有什么问题，但是如果我们想要修改某个环境变量就不太好办了，比如你想修改容器A中的某个参数，就不得不重新打包发布镜像，非常麻烦。于是ConfigMap出现了，读者可以把ConigMap理解为，我们把您程序里的配置文件抽取了出来，进行管理，这个管理的组件就是ConfigMap，您可以把您的配置文件重新挂载回去，容器启动的时候会去读取ConifgMap中的配置，如果我们修改了ConfigMap中的配置，只要重启容器即可。但是需要注意的是，ConfigMap并不是全文件替换的，而是逐个字段替换，如果在ConfigMap中没有查找到某个字段相关的配置，还是会去容器中自带的配置文件去查找。总而言之，假如你使用deployment、statefulSet、daemonSet进行部署应用，那么这个配置查询的顺序是：环境变量 > 命令行配置 > ConfigMap > 容器内自带的配置文件。请注意，ConfigMap通常只用于保存非敏感信息。

##### **密钥管理（Secret）**

Secret 通常翻译成”秘密“、”密匙管理“或是”保密配置“，用于存储和管理敏感信息，如用户密码、密钥、令牌和镜像仓库的认证信息等。虽然 Secret 中的内容是以 base64 编码存储的，但编码并不等同于加密。因此，Secret 的主要目的是保护敏感数据不被直接暴露在配置文件和代码中，而不是对数据进行加密。

读者可以将 Secret 理解为 Kubernetes 中用于存储和管理敏感配置信息的资源。它通常用于保存用户密码、密钥、令牌、证书和私有镜像仓库的认证信息等。通过使用 Secret，可以避免将敏感信息直接硬编码在容器镜像或配置文件中，从而提高系统的安全性。

#### 7. 存储

##### **存储卷（Volume）**

volume通常被翻译成存储卷，其实volume就是将应用存储的内容挂载出来，方便备份和管理，如果挂载到empty上，就是挂载一个空的存储卷，当Pod被调度到一个节点上时，这个卷就会被创建，并且在Pod运行期间可以用于存储数据。一旦Pod被删除，数据也会随之删除。因此，EmptyDir适用于存储临时数据的场景，比如临时文件或缓存。如果挂载到hostPath，就是挂载到pod所在的服务器，是持久化存储的，但是这可能会导致一些问题，比如pod被调度到其他节点上时，会导致新的pod无法读取之前的数据，我们可以用之间提到的selector或label将pod指定到某台节点上解决，除此之外，还可以使用持久化存储卷（pv）和持久化存储声明（pvc），这是一种更方便管理的持久化方式，如果将volume挂载到pvc上，pvc会根据存储类型自动创建挂载或寻找一个符合条件的pv，根据pvc类型的不同可能创建或绑定到hostpath类型、nfs类型、云存储类型或是nas类型等不同类型的pv，当一个pvc被使用时，您无法直接删除这个pvc和与之相连的pv，这涉及到级联删除的问题，我们后续会提到。

##### **持久化存储卷（PersistentVolume, PV）**

持久化存储卷（PV）是 Kubernetes 中的存储抽象，用于为集群中的 Pods 提供持久化存储。PV 可以独立于 Pod 的生命周期存在，并由集群管理员或通过动态供给机制创建。当用户创建持久化存储声明（PVC）时，Kubernetes 会根据 PVC 的需求匹配并绑定相应的 PV，使得 Pod 可以使用 PVC 访问 PV 提供的存储资源。PV 定义了存储容量、访问模式（如 ReadWriteOnce、ReadOnlyMany、ReadWriteMany）和回收策略（Retain、Recycle、Delete）。常见的 PV 类型包括 NFS、AWS EBS、GCE PD、Ceph 和 Azure Disk，每种类型都有其特定的存储类（StorageClass）来管理存储资源。这个过程确保了应用数据的持久性和可管理性。

##### **持久化存储卷声明（PersistentVolumeClaim, PVC）**

持久化存储声明（PVC）是 Kubernetes 中用户请求存储资源的抽象。PVC 允许用户指定所需的存储容量和访问模式（如 ReadWriteOnce、ReadOnlyMany、ReadWriteMany），然后 Kubernetes 会根据这些需求自动匹配并绑定到适合的持久化存储卷（PV）。PVC 独立于 Pod 的生命周期，这意味着即使 Pod 被删除，存储资源仍然保留。PVC 可以由用户创建，PV 可以由管理员预先配置，也可以通过动态供给机制自动创建。动态供给机制依赖于存储类（StorageClass）定义的配置参数。当 PVC 被删除时，与之关联的 PV 处理方式取决于 PV 的回收策略（Retain、Recycle、Delete）。常见的 PVC 类型包括 NFS、AWS EBS、GCE PD、Ceph 和 Azure Disk，每种类型的 PVC 可以与相应类型的 PV 进行绑定，从而确保应用数据的持久性和高效管理。

#### 8. 批量

##### **任务（Job）**

Job通常用来管理一次性任务，比如您想要执行批量脚本，Job就可以很好的帮您完成，Job会控制pod成功完成工作，然后关闭pod，可以通过配置并发执行的pod数量和重试策略来管理Job的执行，当所有Pod成功完成后，Job即被视为完成。对于需要定期运行的任务，可以使用CronJob，它在指定时间调度Job。

##### **定时任务（CronJob）**

CronJob 可以根据配置的时间规则定期执行某项任务，比如清理每月的日志信息，非常适合用于定期备份、清理任务、报告生成等需要在固定时间间隔内执行的任务。通过使用标准的 cron 时间格式，可以定义任务的执行时间，例如每天凌晨 1 点执行任务。此外 CronJob 还可以设置容器的重启策略，例如任务失败时重启容器，确保任务成功完成。CronJob 还提供了任务并发策略，可以选择允许并发执行、禁止并发执行或用新任务替换旧任务。并且可以设置任务启动的截止时间和暂停任务调度的选项，从而提供灵活的任务调度和管理功能。通过这些配置，用户可以轻松管理和自动化定期任务。

#### 9. 总结

本篇讲述了一些 Kubernetes 的基础概念，但由于篇幅所限，有很多内容尚未涉及，我们会在后续的篇章中逐一详细讲解。如果文中有任何错误或不准确之处，欢迎读者批评指正，希望能与大家一起学习，共同进步。
