---
layout:     post   				# 使用的布局（不需要改）
title:      02 kubernetes架构与组件 		# 标题 
subtitle:   Kubernetes 基础系列 			#副标题
date:       2025-01-14 				# 时间
author:     zhaohaiwen 				# 作者
header-img: img/post-bg-2025-01-07.jpg		#这篇文章标题背景图片
catalog: true 					# 是否归档
tags:						#标签
    - Kubernetes 基础系列
---
### Kubernetes 架构与组件介绍

### 一、Kubernetes 架构与组件

在通常情况下，一个简单的kubernetes集群架构如下图：

![Kubernetes 架构与组件](https://hodie-aurora.github.io/img/2025-01-14-02-kubernetes-system-struct.png)

通常情况下，一个Kubernetes集群由多个工作节点（Worker Node）、一个控制平面集群（control plane，也就是Master Node，可能是一个节点，也有可能是多个节点，集群规模越大，Master Node所需要的资源越多，导致Master Node越多）和一个集群状态存储系统（etcd，可以以容器的形式部署在Master Node中，也可以使用集群的方式部署在其他服务器）组成。其中Master负责整个集群的管理工作，为集群提供管理接口。并监控和编排集群中的各个工作节点。

### 二、Master Node

Master Node 是 Kubernetes 集群的控制中枢，负责管理整个集群的状态和资源调度。它主要由三部分组成：API Server、Scheduler、Controller Manager。

#### 1. API Server：

API Server的功能主要分为四个方面：

##### **1、调度与转发**：

API Server可以将kubectl或者其他方式调用API的请求发送给集群内对应的组件进行处理。比如，您使用以下命令：

```bash
kubectl scale --replicas=3 deploy/demo -n test
```

这个请求首先发送到API Server，然后API Server经过认证和授权检查之后，将请求转发给Controller Manager组件，由Controller Manager组件去控制ReplicaSet，从而实现增加Deployment中Pod的数量。

##### **2、权限认证**：

总有源源不断的请求发送向API Server，其中有些请求是未授权的，甚至是恶意的。所以，API Server对请求的认证与授权功能显得尤为重要。API Server通过认证插件（如Token、X.509证书等）验证用户身份，并使用RBAC（基于角色的访问控制）进行授权。

##### **3、状态存储与检索**：

API Server在接收到获取集群内某些组件信息的指令时，会把指令发送到etcd，从etcd中获取各个节点中组件的信息。比如，当您使用以下命令：

```bash
kubectl get nodes
```

API Server会将请求发送到etcd，etcd返回存储的最新的节点状态信息给API Server。哪怕像是 `kubectl describe deploy/demo`这样的命令也是如此。这会让初学者感到十分惊讶，API Server获取信息竟然是从etcd中获取的。事实上，在Kubernetes中，组件（如Kubelet）会定期把节点中的各种状态信息更新到etcd。例如，当Pod的状态发生变化时，Kubelet会将新的状态信息发送给API Server，API Server会再将其存储到etcd中。因此，通过etcd存储的状态数据通常是最新的。

##### **4、扩展性**：

API Server的设计考虑到了扩展性，主要体现在以下几个方面：

- **动态准入控制（Admission Controllers）**：API Server支持动态加载的准入控制器。这些控制器在请求被持久化之前对其进行验证和修改，以确保符合集群的安全和管理策略。准入控制器的主要功能包括：

  - **验证控制器（Validating Admission Controllers）**：在请求被持久化之前，这些控制器检查请求是否符合集群的策略要求。例如，确保新建的Pod使用了批准的镜像，或者配置是否满足安全要求。
  - **变更控制器（Mutating Admission Controllers）**：在请求被持久化之前，这些控制器可以修改请求的内容。例如，自动为新创建的Pod分配特定的标签或注解，确保所有资源都符合集群的标准。

  通过动态准入控制，Kubernetes集群可以灵活地应对不同的安全和管理需求，确保集群的稳定和安全运行。
- **自定义资源定义（CRD）**：通过CRD，用户可以定义新的API资源类型，并使用API Server管理这些自定义资源。CRD使Kubernetes能够支持更多种类的工作负载和应用场景，而不需要修改Kubernetes的核心代码。
- **Webhook**：API Server支持外部Webhook，可用于扩展认证、授权和准入控制。Webhook允许用户将API Server的某些操作挂接到外部服务上，实现自定义的处理逻辑。
- **插件和模块化设计**：API Server采用模块化设计，允许用户根据需要加载或卸载插件和组件，以扩展其功能。

#### 2. Scheduler

scheduler在kubernetes集群中负责将新创建的尚未分配节点的pod分配到合适的节点上，scheduler通过持续监听API Server来捕捉新创建的pod事件，并根据算法对节点进行评估，将pod调度到评分最高的节点上。在评估过程中，scheduler会考虑各种资源限制、亲和性规则（比如使用Selector或Label标签指定pod可用被调度到哪些节点就是亲和性的一种）、拓扑结构（比如将关系密切的pod尽可能的调度到同一地区的机房以减少跨网域所带来的网络延迟）以及节点的当前状态，scheduler会尽可能的平衡负载，尽量避免单一节点的过载，从而达到调度pod并且优化集群整体性能和可靠性的效果。

##### 调度过程：

Scheduler的调度主要分为两个阶段，分别是预选阶段和优选阶段：

###### 预选阶段：（正常情况下默认状态预选阶段只是过滤掉不符合条件的节点，不涉及打分算法，以下顺序为默认顺序，但是Scheduler并行预选时可能会进行优化）

- **节点状态检查**：验证节点是否处于 Ready 状态（确保节点健康）。
- **资源检查**：检查节点是否有足够的 CPU、内存等资源来运行 Pod。
- **污点和容忍度检查**：确认 Pod 是否能容忍节点的污点（Taints）。
- **亲和性和反亲和性规则检查**：确保节点满足 Pod 的亲和性（Node Affinity）和反亲和性（Anti-Affinity）要求。
- **拓扑结构检查**：考虑节点的网络拓扑和区域分布，确保网络延迟最小化。

###### 优选阶段：

- **剩余资源打分**：节点的剩余 CPU 和内存资源越多，得分越高。
- **资源均衡**：倾向于均衡分配资源，避免单一节点过载。
- **网络延迟**：优先选择网络延迟最低的节点。
- **历史性能数据**：根据节点过去的性能表现，选择更稳定和高效的节点。
- **区域优先**：根据配置，优先选择特定区域或可用区的节点。

#### 3. Controller Manager

**Controller Manager** 负责维护集群的状态，实现高可用性和负载均衡。它包含多个控制器，每个控制器负责特定的任务。主要控制器包括：

- **Replication Controller**：确保指定数量的 Pod 副本在集群中运行，通过增删 Pod 来达到期望状态。
- **Endpoint Controller**：将服务与 Pod 关联，维护服务的网络端点。
- **Node Controller**：监控 Node 的状态，处理 Node 的加入和失效。
- **Service Account & Token Controllers**：管理服务账号和 API 访问令牌。

Controller Manager 通过与 API Server 交互，不断地获取和修改集群的状态信息，确保实际状态与期望状态一致。

### 三、Worker Node

### 四、ETCD

### 五、核心组件
