---
layout:     post   				# 使用的布局（不需要改）
title:      GoLang 杂项 		# 标题 
subtitle:   GoLang 系列			#副标题
date:       2025-05-19				# 时间
author:     zhaohaiwen 				# 作者
header-img: img/post-bg-2025-01-07.jpg		#这篇文章标题背景图片
catalog: true 					# 是否归档
tags:						#标签
    - GoLang
---
#### go 调试

##### 时间调试

* time
* /usr/bin/time -v

##### 内存占用分析

* top：快速查看进程整体内存占用，适合初步诊断。
* GODEBUG=gctrace=1：分析 GC 行为和堆内存变化，适合验证内存回收效果。
* runtime.ReadMemStats：精确监控程序内存分配和回收，适合开发阶段。
* pprof：深入分析内存分配来源，适合性能调优和内存泄漏排查。

##### cpu占用分析

* A. Web 界面查看：快速获取 CPU Profile，适合初步分析。
* B. 使用 pprof 工具查看：详细分析函数级 CPU 占用，定位瓶颈。
* C. 通过 go tool pprof 得到 Profile 文件：支持自定义采样时间，适合长时间分析。
* D. 可视化查看：直观展示调用关系，适合团队协作。

#### GPM模型

* 1、M的数量最高1万个，但是不是由人为操控的
* 2、P的队列内G的数量最高256个，而P的数量由环境变量设置
* 3、创建G时首先会被分配到P的队列中，如果P的队列满了就分一半给全局队列
* 4、P如果空了会先从全局队列中获取一部分G。如果获取不到就从其他队列中获取一半G，
* 5、从全局队列中获取的比较慢，因为全局队列有锁
* 6、如果G创建了新的G‘，这个G’优先放在和G一样的P

#### go 逃逸定律

* 地址返回定律：变量地址返回函数外，逃逸到堆。
* 外部引用定律：被全局变量、闭包或外部函数引用，逃逸到堆。
* 指针传递定律：地址传给其他函数且安全性不明，逃逸到堆。
* 动态类型定律：切片、映射、接口或 new/make 对象，逃逸到堆。
* 大对象定律：超大数组或对象超出栈容量，逃逸到堆。
* Goroutine 定律：在 goroutine 中使用，逃逸到堆。
* 反射定律：被反射操作，逃逸到堆。
* 值传递定律：值类型仅传递副本，不逃逸。
* 默认定律：无逃逸条件，分配在栈。

#### make和new的区别

* 相同：堆空间分配
* 不同
  * make: 只用于slice、map以及channel的初始化， 无可替代
  * new: 用于类型内存分配(初始化值为0)， 不常用

#### go 中的interface

interface 是方法声明的集合

* 任何类型的对象实现了在interface 接口中声明的全部方法，则表明该类型实现了该接口。
* interface 可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值。

#### defer 相关

* Defer执行顺序：多个defer按栈（先进后出）执行，前面的defer后执行。
* Defer与Return：return先执行，defer后执行，可修改返回值。
* 返回值初始化：命名返回值在函数起始初始化为零值，作用域为整个函数。
* 有名返回值与Defer：defer可修改return后的命名返回值。
* Defer遇Panic：defer在panic时执行，若无recover抛出错误，有recover继续执行。
* Defer内Panic：仅最后一个panic可被recover捕获，覆盖前面的panic。
* Defer参数子函数：defer压栈时，子函数参数先执行，执行顺序为参数计算后倒序出栈。

#### go 垃圾回收 三色标记法 混合写屏障机制

##### 回收算法

* 标记删除 循环引用问题 STW问题
* 三色标记，白灰黑标记表，白色节点放入白色标记表，灰色节点放入灰色标记表，黑色节点放入黑色标记表，从根节点开始浅层遍历，将遍历到的白色节点标灰，再从灰色节点浅层遍历，将灰色节点标黑，将遍历到的白色节点标灰，循环这一过程，知道灰色标记表内没有节点，清除所有的白色标记表内节点
* 无 STW 时三色标记偶尔发生 白色挂在黑色下，灰色丢失白色，导致白色被清除
* 强三色，直接禁止黑色引用白色
* 弱三色，被灰色引用的白色，或在灰色链路中的白色可以被黑色所引用

##### 屏障机制

* 插入屏障：插入屏障不在栈上使用，被引用对象强制标记为灰色，这样就不存在黑色引用白色的情况了，准备回收白色之前，为栈内空间加STW，重新扫描避免干扰（避免新创建的白色对象被黑色引用，也就是说栈三色扫描两次，STW为10ms~100ms）
* 删除屏障：被取消引用的对象变成灰色，但是回收精度低，即使被取消了全部的引用指针也可以活过这一轮
* 混合写屏障：
  * 1、GC开始将栈上的对象全部扫描并标记为黑色(在标记准备阶段需要一个耗时极短的STW)
  * 2、GC期间，任何在栈上创建的新对象，均为黑色。
  * 3、被取消引用的对象标记为灰色。
  * 4、被添加的对象标记为灰色。

#### 什么是rune类型？

`rune` 是 `int32` 的别名，表示单个 Unicode 代码点，方便处理字符串中的字符，尤其是非 ASCII 字符。
