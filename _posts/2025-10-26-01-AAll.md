---
layout:     post   				# 使用的布局（不需要改）
title:      AFast		# 标题 
subtitle:   AFast					#副标题
date:       2025-10-26				# 时间
author:     zhaohaiwen 				# 作者
header-img: img/post-bg-2025-01-07.jpg		#这篇文章标题背景图片
catalog: true 					# 是否归档
tags:						#标签
    - Fast
---
#### GPM模型

G就是goroutine，也就是协程，几KB的轻量级线程

M就是内核线程

P是逻辑处理器，对应一个存放G的本地队列，

有两种队列，一种是P绑定的本地队列，一种是全局队列

每个M都绑定一个P，P从本地队列取出G交给M运行

工作时，一个G被创建时会放入P的本地队列，如果本地队列满了就放入全局队列，如果P的本地队列空了就从全局队列获取G，如果获取不到就偷取其他P本地队列中的G，这就是工作偷取，通常偷取一半

如果一个G在M上执行时发生了系统调用阻塞，这个M会和G一起被内核阻塞。但Go调度器会让P与这个M解绑，然后去找一个新的M来继续执行P队列里剩下的G，这样就不会浪费CPU。等原来的G阻塞结束，它会被重新放回队列等待执行

#### Go垃圾回收

Go的垃圾回收是基于**三色标记法**的**并发标记清除**算法。

主要分为四步：

1、准备阶段：触发STW，开启混合写屏障

2、并发标记阶段（和程序并发执行）：使用三色标记法进行标记，如果程序修改了对象引用关系，混合写屏障就会介入，将被引用对象变为灰色，防止黑色对象指向白色对象，避免了本该存活的对象被误删

3、标记终止阶段：触发STW，当不存在灰色对象时，关闭混合写屏障

4、并发清除阶段：回收全部白色对象

三色标记：最开始所有对象都为白色

1、第一轮标记：根节点为黑色，被根节点引用的节点变为灰色

2、下一轮标记：灰色变为黑色并且被黑色节点引用的白色节点变为灰色

3、重复这一过程直到不存在灰色对象

4、回收白色对象

混合写屏障存在的意义就是，当并发标记的时候如果程序让一个黑色对象引用了白色对象就直接把白色对象变为灰色，避免白色对象被清除

**在GC开始时会把栈上所有对象直接标黑（这需要STW），并且在堆上启用屏障，当黑色对象引用白色对象时，会把白色对象变灰** 。

#### GPM Plus

**为什么需要 P 这个角色？只有 M 和 G 不行吗？**

不行，因为如果只有 M 和 G，那就退化成了传统的线程池模型，会有两个主要问题：

1. **全局锁竞争严重** ：所有 M 都需要从一个全局的 G 队列里获取任务。在高并发时，M 会激烈争抢这把全局锁，导致性能瓶颈。引入 P 之后，每个 M 优先在自己的本地队列上操作，几乎没有锁竞争，效率极高。
2. **缓存亲和性差** ：如果一个 G 在不同的 M（也就是不同的 CPU 核心）上被来回调度，它之前在某个 CPU 核心上运行时产生的缓存数据就会失效，导致 CPU 缓存命中率下降。P 的存在，让 G 倾向于在同一个 P 上被调度，从而更有可能在同一个 M 上执行，能更好地利用 CPU 缓存。

所以，P 的作用就是 **解耦 M 和 G** ，充当一个中间层，来**消除全局锁**并 **提高缓存命中率** 。

**P 的数量是由什么决定的？可以调整吗？**

P 的数量由 `runtime.GOMAXPROCS` 这个参数决定，在 Go 1.5 版本之后，它 **默认等于 CPU 的逻辑核心数** 。

它是可以调整的。我们可以通过设置环境变量 `GOMAXPROCS` 或者在代码里调用 `runtime.GOMAXPROCS()` 函数来修改它。

这个值的意义在于，它决定了 **同一时间最多有多少个 Goroutine 可以真正地并行执行** 。通常情况下，对于 CPU 密集型任务，保持默认值（等于 CPU 核心数）就是最佳选择，因为更多的 P 也不会有更多 CPU 资源。

但在 IO 密集型应用中，因为 Goroutine 会频繁因 IO 阻塞而让出 M，适当调大 P 的数量有时能提升一点性能，但通常默认值已经是很好的实践了。

**如果一个 Goroutine 执行了很长时间的计算（比如死循环），会发生什么？会阻塞其他 G 吗？**

不会一直阻塞其他 G。因为 Go 的调度器是**抢占式**的。

在 Go 1.14 版本之后，引入了 **基于信号的抢占式调度** 。当一个 Goroutine 连续运行超过一个固定的时间片（比如 10ms）时，Go 运行时会向它所在的 M 发送一个信号，强制中断这个 Goroutine 的执行，把它重新放回队列的末尾，然后 M 会去执行队列里的其他 Goroutine。

这样就保证了调度的公平性，即使有少数计算密集的 Goroutine，也不会饿死其他需要执行的 Goroutine，保证了整个程序的响应性。

* 1、M的数量最高1万个，但是不是由人为操控的
* 2、P的队列内G的数量最高256个，而P的数量由环境变量设置
* 3、创建G时首先会被分配到P的队列中，如果P的队列满了就分一半给全局队列
* 4、P如果空了会先从全局队列中获取一部分G。如果获取不到就从其他队列中获取一半G，
* 5、从全局队列中获取的比较慢，因为全局队列有锁
* 6、如果G创建了新的G‘，这个G’优先放在和G一样的PG

#### Go 垃圾回收 Plus

它的核心思想是：

1. 把内存里的对象分为**白、灰、黑**三种。白色是潜在的垃圾，灰色是待扫描对象，黑色是绝对存活的对象。
2. GC开始时，先把所有对象都看作白色。从根对象（比如全局变量、栈上的对象）出发，找到的对象标记为灰色。
3. 之后，不断地从灰色对象集合中取出对象，把它标记为黑色，并把它引用的所有白色对象标记为灰色。
4. 当没有灰色对象时，剩下的所有白色对象就是垃圾，可以被回收。

* **插入写屏障（Go 1.7及之前）** ：当一个黑色对象A要引用一个白色对象B时，写屏障会 **强制把白色对象B也变成灰色** 。这样就保证了B后续一定会被扫描，不会被漏掉。它的缺点是，GC结束时需要对栈进行重新扫描，STW时间较长。
* **混合写屏障（Go 1.8及之后）** ：它的核心规则是： **一个对象被标记为黑色后，它就不能再指向白色对象** 。为了遵守这个规则，写屏障会做两件事：
* 如果一个在栈上的对象被引用，就把它标记为灰色（防止栈扫描时漏掉）。
* 如果一个在堆上的对象被引用，就把它旧的引用标灰，新的引用也标灰。
