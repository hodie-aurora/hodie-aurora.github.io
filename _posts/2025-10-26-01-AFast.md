---
layout:     post   				# 使用的布局（不需要改）
title:      AFast		# 标题 
subtitle:   AFast					#副标题
date:       2025-10-26				# 时间
author:     zhaohaiwen 				# 作者
header-img: img/post-bg-2025-01-07.jpg		#这篇文章标题背景图片
catalog: true 					# 是否归档
tags:						#标签
    - Fast
---
#### GPM模型

G就是goroutine，也就是协程，几KB的轻量级线程

M就是内核线程

P是逻辑处理器，对应一个存放G的本地队列，

有两种队列，一种是P绑定的本地队列，一种是全局队列

每个M都绑定一个P，P从本地队列取出G交给M运行

工作时，一个G被创建时会放入P的本地队列，如果本地队列满了就放入全局队列，如果P的本地队列空了就从全局队列获取G，如果获取不到就偷取其他P本地队列中的G，这就是工作偷取，通常偷取一半

如果一个G在M上执行时发生了系统调用阻塞，这个M会和G一起被内核阻塞。但Go调度器会让P与这个M解绑，然后去找一个新的M来继续执行P队列里剩下的G，这样就不会浪费CPU。等原来的G阻塞结束，它会被重新放回队列等待执行

#### Go垃圾回收

Go的垃圾回收是基于**三色标记法**的**并发标记清除**算法。

主要分为四步：

1、准备阶段：触发STW，开启混合写屏障

2、并发标记阶段（和程序并发执行）：使用三色标记法进行标记，如果程序修改了对象引用关系，混合写屏障就会介入，将被引用对象变为灰色，防止黑色对象指向白色对象，避免了本该存活的对象被误删

3、标记终止阶段：触发STW，当不存在灰色对象时，关闭混合写屏障

4、并发清除阶段：回收全部白色对象

三色标记：最开始所有对象都为白色

1、第一轮标记：根节点为黑色，被根节点引用的节点变为灰色

2、下一轮标记：灰色变为黑色并且被黑色节点引用的白色节点变为灰色

3、重复这一过程直到不存在灰色对象

4、回收白色对象

混合写屏障存在的意义就是，当并发标记的时候如果程序让一个黑色对象引用了白色对象就直接把白色对象变为灰色，避免白色对象被清除

**在GC开始时会把栈上所有对象直接标黑（这需要STW），并且在堆上启用屏障，当黑色对象引用白色对象时，会把白色对象变灰** 。
